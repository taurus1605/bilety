# Плюсы
## 1. Директивы препроцессора (`#include`, `#define`). Функция main()

Препроцессор запускается до компилятора и преобразовывает исходный код в код, который видит компилятор. Каждая строка, которая начинается с #, представляет собой директиву препроцессора.
`#include` директива указывает, что код должен включить содержимое какого-то файла в исходный текст вместо самой директивы. Для стандартных заголовочных файлов используются `<>`, для других `""`.
Примеры: 
```cpp
#include <iostream>
#include "tracer.h"
```
`#define` директива выполняет определяет макропостановки, которые будет проводить препроцессор.
Например, написав `#define abc xyz` компилятор вместо исходного кода:
```cpp
int abc = 1;
int abcd = 2;
```
Увидит:
```cpp
int xyz = 1;
int abcd = 2;
```
Слово, на которое будет выполнена замена - это макрос. Макросы принято писать uppercase-ом.
Также с помощью define можно определить макросы с параметрами.
```cpp
// пример макроса, который определяет максимум 2 объектов.
#define MAX(x, y) ( ((x) > (y)) ? (x) : (y) ) 
```
Все программы, написанные на С++, должны содержать функцию с именем `main()`. Ей дается управление после запуска программы. Она может возвращать значения в вызвавшую систему. Функция `main()` может быть без параметров и с параметрами:
```cpp
int main();
int main(int argc, char* argv[]);
```

## 2. Встроенные типы данных. Строки std::string и массивы std::vector
Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать.
В языке C++ определены следующие базовые типы данных:
+ логический (bool)
+ символьный (char), 
+ целочисленный (int, unsigned int), 
+ вещественный (double, float)
С помощью них можно реализовать все идеи и создавать собственные типы. `std::string` - массив символов хранящий свой размер и имеющий свои методы,
`std::vector` - массив содержащий элементы одного типа данных, хранящий свой размер и  имющий свои методы.

## 3. Константы. Квалификаторы `const` и `constexpr`
Квалификаторы `const` и `constexpr` говорят о том, что значения хранящиеся в памяти под этим именем именять нельзя. 
значние с квалификатором constexpr - обязано быть известно на этапе компиляции, а вот const - нет.
```cpp
const a = 12; // может быть и не известна во время компиляции
constexpr b = 15; // должна быть известна во время компиляции
```

## 4. Арифметические и логические операторы. Операции с присваиванием. Приоритет
С++ поддерживает арифметические операторы `+`, `-`, `*`, `/`, `%` (определен только для целочисленных типов)
Деление по умолчанию целочисленное, если оба параметра целочисленные, и дробное, если хотя бы один параметр нецелочисленный. Операторы `+` и `-` так же могут быть унарными. Существуют также операторы с присваиванием, как то `+=`, `-=`, `*=`, `/=`. Операторы декремента `--` и инкремента `++` бывают двух типов - постфиксный, который возвращает значение до изменения (которое является r-value!!!), и префиксный, возвращающий значение после его изменения (и оно l-value).
Логические операторы - `<`, `<=`, `>`, `>=`, `!(отрицание)`, `!=` и `==`.
Приоритет операций - самый низкий у присваивающих, потом `+` и `-`, потом `%`, потом `++` и `—`, потом `*` и `/`. Логические операторы имеют приоритет ниже, чем арифметические.  
Важно: при перегрузке арифметических операторов нужно, чтобы оператор возвращал r-value ссылку на объект , к которому применен оператор (или просто его копию).
Это необходимо для того, чтобы, например, запись `if (i + i > j)` была корректной.
При перегрузке оператора= нужно возвращать ссылку на объект, чтобы запись `std::cout << e = 5;` была корректна.

## 5. Операторы ветвления if-else и switch. Конструкция else-if
Операторы ветвления нужны в случае, когда код должен работать по разному в зависимости от каких-либо условий.
Синтаксис `if-else`:
```cpp
if (condition1) {
  // code ...
}
else if (condition2) {
  // code ...
}
else {
  // code ...
}
```
Преимущества `if-else` по сравнению с `switch`:
+ работает с любыми условиями
Синтаксис switch:
```cpp
switch (expression) {
  case val1: // code ...
  case val2: // code ...
  default:   // code ...
}
```
Правила `switch`:
+ работает с перечислениями, `char` и `int`
+ значения меток `case` - константные выражения
+ метки имеют уникальные значения
+ метка должна завершаться ключевым словом `break`, чтобы не перейти к выполнению кода следующего блока `case`
Преимущества switch по сравнению с `if-else`:
+ работает быстрее

## 9. Динамическое выделение памяти. Операторы new-delete и new[]-delete[]
С помощью оператора new (`new[]` для массивов) выделяется память из динамической памяти (или кучи), а с помощью delete (`delete[]` для массивов) - освобождается.
Оператор new выполняет выделение динамической памяти:
+ возвращает указатель на выделенную память (адрес первого байта выделенной памяти)
+ указатель указывает на объект определенного типа
+ указатель не знает количество элементов, на которые он указывает
```cpp
int* pi = new int; // one element
int* qi = new int[10]; // array
```
Написав `int* pi = new int[5];` мы получим указатель `pi`, который указывает на первый элемент массива целочисленных значений:
```cpp
pi:[...]
   /
[...][...][...][...][...]
```
Для того, чтобы найти нужный элемент с помощью оператора `[]` используется информация о размере типа, поэтому нельзя присвоить указателю на один тип указатель на другой тип.
Основная проблема работы с указателями: указатель не знает, на какое количество элементов он указывает. Из-за этого может возникнуть выход за пределы диапазона.
При работе с динамической памятью через `new-delete` лучше пользоваться правилом: "На каждый `new` нужен свой `delete`". Это позволит избежать утечек памяти.
В процессе работы может возникнуть грубая ошибка - двойное удаление памяти.
Оператор new сначала выделяет память, а затем вызывает конструктор(-ы) нужного типа, оператор delete вызывает деструктор(-ы), а потом освобождает память.

## 13. Перечисления enum class и "простые" перечисления
Перечисление - простой пользовательский тип, задающий множество значений в виде символических констант. Каждому значению Month имеет эквивалентное целочисленное значение. Каждому элементу можно задать определенное значение, можно задать значение первого элемента (тогда каждому элементу будет присвоено значение предыдущего, увеличенное на единицу), можно вообще не задавать значений, тогда отсчет начнется с нуля.
Пример:
```cpp
enum class Color
{
  red, yellow, green, blue, brown, black, white
}
```
Ключевое слово `class` означает, что элементы находятся в области видимости перечисления, то есть доступ к ним происходит через указание имени области видимости (например, `Color::white`). Отсутствие `class` означает, что элементы не будут находиться в текущей области видимости, а не в области видимости перечисления. Такие перечисления называются "простыми". Элементы простых перечислений могут быть неявно преобразованы в `int`. Простые перечисления могут загрязнять область видимости.
Применение перечислений:
```cpp
enum class Color { white /*, etc*/ }
//...
Color c = Colot::white;
```

## 17. Наследование. Ключевые слова virtual и override
Наследование - один из основополагающих принципоп парадигмы объектно-ориентированного программирования. Благодаря наследованию можно избежать дублирования кода, к тому наследование помогает логически организовать код. Класс, от которого происходит наследование, называется "родительским" ("суперклассом", "базовым"), а класс, который наследует - "дочерний" ("подкласс", "производный").
Синтаксис наследования:
```cpp
class sub_class : <inheritance_type> super_class
{ ... }
```
Типы наследования:
+ `public` (уровень доступа к данным не меняется)
+ `protected` (`public` становится protected, остальное не меняется)
+ `private` (все унаследованные данные становятся `private`)
Виртуальные функции - функции родительского и дочернего класса с одинаковыми именами, возвращаемыми типами и типами аргументов. Эта возможность позволяет реализовать полиморфизм времени выполнения (или, по-другому, динамическая диспетчеризация). Для обработки виртуальных функций классу требуются `vtbl` (таблица виртуальных функций) и vptr (указатель на `vtbl`). При вызове метода для объекта x какого-то класса код перейдет через таблицу виртуальных функций к нужной функции для вызова.
```cpp
virtual void do_something ();
```
Создается виртуальная функция с помощью спецификатора `virtual`. Виртуальную функцию может переопределить дочерний класс.
Абстрактный класс - класс, который можно использовать только в качестве родительского.
Сделать класс абстрактным можно созданием чисто-виртуальной функции (функции, которыми должны быть определены в дочерних классах).
```cpp
virtual void do_something () = 0;
```
Для указания того, что функция должна перекрывать виртуальную функцию базового класса, используется ключевое слово `override`.
Пример:
```cpp
class Enemy
{
virtual void attack () = 0;
virtual void run () { /*code*/ };
};
class Soldier : public Enemy
{
void attack () override { /*code*/ };
void run () override { /*code*/ }
};
```

## 21. Обработка ошибок. Возможные альтернативы. Механизм исключений
Классификация ошибок:
+ ошибки времени компиляции (`compilation errors`): синтаксические ошибки, ошибки типов и тд
+ ошибки времени выполнения (`run time errors`): ошибки, обнаруженные компьютером, библиотекой или кодом пользователя
+ ошибки времени редактирования связей: ошибки при попытке объединения объектных файлов в выполнимый модуль
+ логические ошибки (`logic errors`)
Случаи, в которым можно не обрабатывать ошибки:
+ ошибки аппаратного обеспечения, операционной системы
+ нет возможности изменить определение функции
+ пользователю нужно знать об ошибки, что предпринять какие-либо действия
+ значительное уменьшение производительности в случае обработки
Две альтернативы обработки ошибок:
+ обработка в вызывающем коде (непрактично, кроме случая, когда нет доступа к изменению вызываемого кода, то есть добавления обработки; может привести к дублированию кода, его нечитаемости)
+ обработка в вызываемом коде (логичный выход; в некоторых случаях невозможно реализовать)
Механизм исключений (реализуется с помощью try, catch и throw). Основная идея: отделение кода, который может генерировать исключения, от кода, обрабатывающего эти исключения.
Синтаксис:
```cpp
try {
  // код ... 
}
catch (/*тип ошибки или "..." для любых случаев*/) {
  // обработка ошибки ...
}
```
Может быть несколько блоков `catch` для разных типов.
Обычно в блоке `catch`:
 - выводится сообщение об ошибке
 - исключение отправляется "выше", в другой блок `try-catch`
Исключения генерируются с помощью оператора `throw`
```cpp
throw std::runtime_error{"error"};
throw "error";
throw -1;
```

## 22. Способы организации структуры и взаимодействия в программе:
### 22.2. Функции. Механизм вызова, организация стека активационных записей. Рекурсия
Функция - фрагмент программного кода, к которому можно обратиться из другого места программы. В языке C++ допускаются именованные и безымянные (`lambda`) функции. После выполнения функции управление возвращается обратно в адрес вызова - точку программы, откуда данная функция была вызвана.
При вызове функции реализация ЯПа создает структуру данных, содержащую копии всех ее параметров и локальных переменных.
Например, вызывая функцию:
```cpp
int sum (int a, int b)
{
  int res = a + b;
  return res;
}
```
Компилятор создаст структуру (запись активации функции), хранящую в себе `a`, `b` и `res`, а также детали реализации, которые варьируются от компилятора к компилятору.
С точки зрения реализации параметр представляет собой всего лишь одну из локальных переменных.
Вывозвы функций хранятся в стеке. Вызовы обрабатываются по принципу (последний добавился - первый вышел). То есть при добавлении вызова функции в стек вызовов, сначала обработается вызванная функция, а затем программа вернется к месту вызова. Такой стек называется стеком записей активации (или стек вызовов).
Рекурсия - вызов функции в самой функции. Ввиду существования рекурсии был существует и рекурсивный подход - использование рекурсии в алгоритмах.
Пример рекурсии:
```cpp
int pow (int a, int n)
{
  if (n == 1)
    return a;
  else
    return a * pow(a, n-1);
}
```
Во время написания рекурсивных функций надо продумать правильное условия выхода, иначе рекурсия может стать бесконечной.
### 22.3. Способы передачи параметров в функцию
Существуют разные способы передачи параметров в функцию:
+ Передача копированием (`int f (int f);`). Используется для базовых или маловесных типов. При передаче массивных данных следует использовать один из 2 следующих типов.
+ Передача по ссылке (`int multiple (std::vector<int>& v, int a);`). Используется в случае, если переданную переменную нужно изменить.
+ Передача по константной ссылке (`int sum (cosnt std::vector<int>& v);`). Используется для оптимизации по памяти, чтобы исключить копирование. Причем лучше использовать именно константную сслылку, если нет надобности изменять данные.
+ Передача функции (`double integral (double (*f)(double));`, или `double integral (double (f)(double));`, или `double integral (double f(double));`). Случаи использования очевидны.

















