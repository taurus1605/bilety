# Плюсы

> Над проектом трудятся: Шарипов Тимур, Осипян Арсен, Рубченко Павел, Иванов Александр, Тян Валерий и Фатин Данила

## :warning: Work in progress :construction: :construction_worker:
- [x] 1
- [x] 2
- [x] 3
- [x] 4
- [x] 5
- [x] 6
- [x] 7
- [x] 8
- [x] 9
- [x] 10
- [x] 11
- [x] 12
- [x] 13
- [x] 14
- [ ] 15
- [x] 16
- [x] 17
- [x] 18
- [ ] 19
- [x] 20
- [x] 21
- [ ] 22
- [ ] 23
- [x] 24

## 1. Директивы препроцессора (`#include`, `#define`). Функция main()

Препроцессор запускается до компилятора и преобразовывает исходный код в код, который видит компилятор. Каждая строка, которая начинается с #, представляет собой директиву препроцессора.
`#include` директива указывает, что код должен включить содержимое какого-то файла в исходный текст вместо самой директивы. Для стандартных заголовочных файлов используются `<>`, для других `""`.
Примеры: 
```cpp
#include <iostream>
#include "tracer.h"
```
`#define` директива выполняет определяет макропостановки, которые будет проводить препроцессор.
Например, написав `#define abc xyz` компилятор вместо исходного кода:
```cpp
int abc = 1;
int abcd = 2;
```

Увидит:
```cpp
int xyz = 1;
int abcd = 2;
```
Слово, на которое будет выполнена замена - это макрос. Макросы принято писать uppercase-ом.
Также с помощью define можно определить макросы с параметрами.
```cpp
// пример макроса, который определяет максимум 2 объектов.
#define MAX(x, y) ( ((x) > (y)) ? (x) : (y) ) 
```

Все программы, написанные на С++, должны содержать функцию с именем `main()`. Ей дается управление после запуска программы. Она может возвращать значения в вызвавшую систему. Функция `main()` может быть без параметров и с параметрами:
```cpp
int main();
int main(int argc, char* argv[]);
```

## 2. Встроенные типы данных. Строки std::string и массивы std::vector
Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать.
В языке C++ определены следующие базовые типы данных:
+ логический (bool)
+ символьный (char), 
+ целочисленный (int, unsigned int), 
+ вещественный (double, float)
С помощью них можно реализовать все идеи и создавать собственные типы. `std::string` - массив символов хранящий свой размер и имеющий свои методы,
`std::vector` - массив содержащий элементы одного типа данных, хранящий свой размер и  имющий свои методы.

## 3. Константы. Квалификаторы `const` и `constexpr`
Квалификаторы `const` и `constexpr` говорят о том, что значения хранящиеся в памяти под этим именем именять нельзя. 
значние с квалификатором constexpr - обязано быть известно на этапе компиляции, а вот const - нет.
```cpp
const a = 12; // может быть и не известна во время компиляции
constexpr b = 15; // должна быть известна во время компиляции
```

## 4. Арифметические и логические операторы. Операции с присваиванием. Приоритет
С++ поддерживает арифметические операторы `+`, `-`, `*`, `/`, `%` (определен только для целочисленных типов)  
     Деление по умолчанию целочисленное, если оба параметра целочисленные, и дробное, если хотя бы один параметр нецелочисленный. Операторы `+` и `-` так же могут быть унарными. Существуют так
     же операторы с присваиванием, как то `+=`, `-=`, `*=`, `/=`. Операторы декремента `--` и инкремента `++` бывают двух типов - постфиксный, который возвращает значение до изменения (которое
     является r-value!!!), и префиксный, возвращающий значение после его изменения (и оно l-value).
     Логические операторы - `<`, `<=`, `>`, `>=`, `!(отрицание)`, `!=` и `==`, `&&`, `||`.
     Приоритет операций - самый низкий у присваивающих, потом `+` и `-`, потом `%`, потом `++` и `—`, потом `*` и `/`. Логические операторы имеют приоритет ниже, чем арифметические.  
     Важно: при перегрузке арифметических операторов нужно, чтобы оператор возвращал r-value ссылку на объект , к которому применен оператор (или просто его копию).
     Это необходимо для того, чтобы, например, запись `if (i + i > j)` была корректной.
     При перегрузке оператора= нужно возвращать ссылку на объект, чтобы запись `std::cout << e = 5;` была корректна.
     
## 5. Операторы ветвления if-else и switch. Конструкция else-if
Операторы ветвления нужны в случае, когда код должен работать по разному в зависимости от каких-либо условий.
Синтаксис `if-else`:
```cpp
if (condition1) {
  // code ...
}
else if (condition2) {
  // code ...
}
else {
  // code ...
}
```
Преимущества `if-else` по сравнению с `switch`:
+ работает с любыми условиями
Синтаксис switch:
```cpp
switch (expression) {
  case val1: // code ...
  case val2: // code ...
  default:   // code ...
}
```
Правила `switch`:
+ `expression` должно быть интегральным (конвертируемым в целое число) типом
+ работает с перечислениями, `char` и `int`
+ значения меток `case` - константные выражения
+ метки имеют уникальные значения
+ метка должна завершаться ключевым словом `break`, чтобы не перейти к выполнению кода следующего блока `case`
Преимущества switch по сравнению с `if-else`:
+ работает быстрее    

## 6. Операторы цикла: `while`, `do-while`, `for`. Операторы `break`, `continue`
 Для многократного повторения действий предусмотрена итерация(циклы):
```cpp
   int i = 0;

   while(i < 100) //условие цикла, проверяющее значение счетчика
   {
	++i  // тело цикла, выполнение которого будет повторяться
   }
   for (int i = 0; i < 100; ++i) { }

    do
    { 
    // гарантированно выполнит как минимум одну итерацию (делает, потом проверяет)
    }
    while() 
```

##### Операторы break и continue:
* В контексте оператора switch оператор break обычно используется в конце каждого кейса для его завершения (предотвращая fall-through).
* В контексте циклов оператор break используется для завершения работы цикла раньше времени.
* Оператор continue позволяет сразу перейти в конец тела цикла, пропуская весь код, который находится под ним.
---
 Это полезно в тех случаях, когда мы хотим завершить текущую итерацию раньше времени.

## 7. Оператор `throw` и блоки `try-catch`
Данные конструкции нужны для обработки ошибок, возникающих при работе кода (runtime-errors). Код, в котором могут возникнуть ошибки времени исполнения (практически любой код :laughing:)
Есть два типа исключений: сгенерированые нами и сгенерированные кодом. Для генерации исключения необходимо использовать ключевое слово `throw`:
```cpp
if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");

```
Мы создали исключение, но никак его не обработали. Для обработки исключений необходим блок `try-catch`:
```cpp
try 
{
    // Здесь помещаем код, в котором могут быть runtime-errors

    int n = -10;
    if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");
  
}
catch (std::exception& e)
{
    // Здесь перехватываем исключение и выводим сообщение об ошибке
    std::cerr << e.what() << std::endl;
}
```
Обратите внимание на выражение `e.what()` - оно позволяет получить строку с информацией об ошибке.

Вообще, есть стандартная конструкция для обработки ошибок, которую я вижу во всех программах, где ошибки хоть как-то обрабатываются:
```cpp
int main()
try
{
  
}
catch (std::exception& e) {

    std::cout << e.what() << std::endl;

    return 1;
}
catch (...) {

std::cout << "Commander, we need more rockets" << std::endl;

return 2;
}
```
Выражение `catch(...)` перехватывает все типы ошибок. То есть, если ошибка не была поймана в `catch (std::exception& e)`, она обязательно попадет в блок с `catch(...)`

## 8. Память, адреса, указатели и ссылки. Арифметика указателей
Работа с памятью в `С++` требует аккуратности. Для получения адреса объекта к нему нужно применить унарный оператор `&`. Он вернет указатель на ту ячейку памяти, где находится данный объект.
Для разыменовывания применяют унарный оператор `*`, который принимает указатель, а возвращает ссылку на объект по этому адресу. Разыменовывать указатель `void*` запрещено! Если объект типа `T`,
то тип указателя на этот объект - `T*` (`int*`, `char*` - указатели на `int` и `char` соответственно). Для обращения к полям объекта используется оператор `.` (`myClass.method()`). Стоит заметить,
что имена объектов - это ссылки на этот объект. Если нужно обратиться к полю класса через указатель на объект класса, то используется оператор `->` (`myClassPointer->method()`).
Ссылка на объект уникальна, у вас не может быть в программе 2 ссылки на один и тот же объект (не может быть 2 переменные с одним названием), а вот указателей может быть сколько угодно.
Еще один важный момент: если у вас есть указатель, указывающий на несколько ячеек памяти (например, `int* p = new int[5]`), то применение к нему !`operator[]` (`p[i]`)возвращаемым значением
будет разыменнованный объект по адресу `p + i`; то есть следующие записи эквивалентны: `p[i]` и `&(p+i)`. Вторая скобка представляет собой арифметику указателей. На какое количество байт
перепрыгнет указатель, если записать `p+1`, определяет тип указателя.


## 9. Динамическое выделение памяти. Операторы new-delete и new[]-delete[]
С помощью оператора new (`new[]` для массивов) выделяется память из динамической памяти (или кучи), а с помощью delete (`delete[]` для массивов) - освобождается.
Оператор new выполняет выделение динамической памяти:
+ возвращает указатель на выделенную память (адрес первого байта выделенной памяти)
+ указатель указывает на объект определенного типа
+ указатель не знает количество элементов, на которые он указывает
```cpp
int* pi = new int; // one element
int* qi = new int[10]; // array
```
Написав `int* pi = new int[5];` мы получим указатель `pi`, который указывает на первый элемент массива целочисленных значений:
```cpp
pi:[...]
   /
[...][...][...][...][...]
```
Для того, чтобы найти нужный элемент с помощью оператора `[]` используется информация о размере типа, поэтому нельзя присвоить указателю на один тип указатель на другой тип.
Основная проблема работы с указателями: указатель не знает, на какое количество элементов он указывает. Из-за этого может возникнуть выход за пределы диапазона.
При работе с динамической памятью через `new-delete` лучше пользоваться правилом: "На каждый `new` нужен свой `delete`". Это позволит избежать утечек памяти.
В процессе работы может возникнуть грубая ошибка - двойное удаление памяти.
Оператор new сначала выделяет память, а затем вызывает конструктор(-ы) нужного типа, оператор delete вызывает деструктор(-ы), а потом освобождает память.

## 10. Массивы: одномерные и многомерные. Строки символов в стиле C
Массив - это однородный, упорядоченный структурированный тип данных с прямым доступом к элементам.  
Элементы массива объединяются общим именем и занимают в компьютере определенную конечную область памяти.  
К любому элементу массива можно обратиться, указав имя массива и индекс элемента в массиве `int a[7]`
Массивы с двумя индексами называют двумерными `int b[3][4]`
Такие массивы можно представить в виде таблицы, в которой номер строки соответствует первому индексу,
а номер ячейки в строке (номер столбца) - второму индексу.
Строка в стиле Cи представляет собой массив символов, заканчивающийся нулевым символом ( так называемый, терминальный ноль `'\0'` ) :
```cpp
char str[100]; char st[] = "tratata eto stroka";
```

## 11. Функции. Прототип и определение. Возвращаемое значение. Формальные и фактические параметры. constexpr-функции.
#### Функции
Функции позволяют нам удобно организовывать код переиспользовать его в разных местах. Запомните, идеальная функция должна делать лишь 
одно действие и делать это хорошо и эффективно. А так же хорошая фнукция должна умещаться на экране твоего монитора)

#### Прототип и определение. Возвращаемое значение
Объявление функции состоит из типа возвращаемого значения, за которым
следуют имя функции и список формальных аргументов в круглых скобках.
например: 
```cpp
double fct(int a, double d); // прототип функции fct без тела (объявление)
double fct(int a, double d) // определение функции fct
{
    return a * d;
}
```
> Важное замечание: вы не можете использовать функцию до её объявления или определения. То есть нужно объявить или определить функцию выше того кода, где она используется.

Определение содержит тело функции (инструкции, выполняемые при ее вызове), в
то время как объявление, не являющееся определением, просто завершается
точкой с запятой. Формальные аргументы часто называют параметрами
(parameters). Если вы не хотите, чтобы функция имела аргументы, не указывайте
параметры:
```cpp
int current_Power ( ) ; // Эта функция не принимает аргументов
```
Если хотите, чтобы функция не возвращала никаких значений, укажите вместо
типа возвращаемого значения ключевое слово `void`, например:
```cpp
void increase_Power ( int level); // Функция ничего не возвращает 
```
Функция возвращает вычисленное значение с помощью инструкции return. 
```cpp
T f() // Функция f() возвращает объект класса T
 {
    V v;
    // ...
    return v;
}
```
Здесь возвращаемое значение - это именно то значение, которые мы получили бы
при инициализации переменной типа `T` значением типа `v`.
Таким образом, возврат значения - это разновидность инициализации. 

#### constexpr-функции
Функция представляет собой вычисление, и иногда хотелось бы выполнить его
еще во время компиляции. Причиной такого желания обычно является то, что это
приводит к огромной экономии этих же вычислений во время выполнения
программы. Мы используем функции, чтобы сделать наши расчеты понятными,
поэтому, естественно, мы иногда хотим использовать функцию в константном
выражении. Мы выражаем наше намерение заставить вычислить значение
функции компилятором, объявляя ее как constexpr. Такая функция может
вычисляться компилятором, если в качестве аргументов функции используются
константные выражения, например: 
```cpp
constexpr double xscale = 10;
constexpr double yscale = 5;
```
Объявленная как constexpr функция ведет себя так же, как обычная функция - до
тех пор, пока вы не используете ее там, где необходима константа. Тогда она
вычисляется во время компиляции при условии, что ее аргументами являются
константные выражения, и приводит к ошибке, если они не 
являются таковыми. Чтобы это было возможно, функция,
объявленная как `constexpr`. должна быть настолько простой, чтобы компилятор
(любой компилятор, соответствующий стандарту) мог ее вычислить. В С++ 11 это
означает, что функция, объявленная как constexpr, должна иметь тело, состоящее
из одной инструкции `return`
```cpp
int gob = 9;

constexpr void bad(int& arg)    // Ошибка: нет возвращемого значения
{
    ++arg; // Ошибка: модификация значения переменной вне тела с помощью аргумента
    glob = 7; // Ошибка: модифицирует нелокальную переменную

}
```

## 12 Классы. Поля и методы. Части класса. Указатель `this`. Деструктор.
Классы - это пользовательские типы в `С++`. Классы объявляются за границей функций. Для объявления класса есть 2 ключевых слова - `struct` и `class`. Синтаксис следующий:
```cpp
class MyClass {
public:
    //code
private:
    //code
protected:
    //code
};
```
Разница в `struct` и `class`состоит только лишь в том, что в `class` все поля по умолчанию `private`, а в `struct` - `public`. То есть запись
```cpp
class Myclass {
private:
    int int1;
public:
    int int2;
};
```
полностью эквивалентна
```cpp
class Myclass {
    int int1;

public:
    int int2;
};
```

Точка с запятой в конце объявления класса обязательна. В классе есть 3 раздела - `public:`, `private:` и `protected:`. Члены класса, записанные после метки `public`, являются публичными
и доступны к обращению извне класса: `obj.field`. Поля после метки `private` доступны только изнутри класса, то есть только в его методах. Пользователь класса к этим членам обратиться не может.
Поле `protected` - поле, которое доступно только дочерним классам, в отличие от полей `private`, которые дочерним классам недоступны.

Если в классе объялвен метод, название которого совпадает с названием класса, то такой метод называется конструктором. Конструктор не имеет возвращаемого значения!
Метод, название которого совпадает с названием класса, но начинается с `~`, называется деструктором:
```cpp
class MyClass {
public:
    MyClass(); //Конструктор
    ~Myclass(); //Деструктор
};
```
Согласно `RAII`, если объект запросил ресурсы в конструкторе, то он должен их вернуть в деструкторе.

Если необходимо получить доступ к объекту, из которого вызван метод класса, используется ключевое слово `this`, которое является указателем этот самый объект. Для него доступны операции
разыменовывания `*` и обращения к полям через `->`

## 13. Перечисления enum class и "простые" перечисления
Перечисление - простой пользовательский тип, задающий множество значений в виде символических констант. Каждому значению Month имеет эквивалентное целочисленное значение. Каждому элементу можно задать определенное значение, можно задать значение первого элемента (тогда каждому элементу будет присвоено значение предыдущего, увеличенное на единицу), можно вообще не задавать значений, тогда отсчет начнется с нуля.
Пример:
```cpp
enum class Color
{
  red, yellow, green, blue, brown, black, white
}
```
Ключевое слово `class` означает, что элементы находятся в области видимости перечисления, то есть доступ к ним происходит через указание имени области видимости (например, `Color::white`). Отсутствие `class` означает, что элементы не будут находиться в текущей области видимости, а не в области видимости перечисления. Такие перечисления называются "простыми". Элементы простых перечислений могут быть неявно преобразованы в `int`. Простые перечисления могут загрязнять область видимости.
Применение перечислений:
```cpp
enum class Color { white /*, etc*/ }
//...
Color c = Colot::white;
```

## 14. Перегрузка операторов.   
Перегрузка операторов - для класса или перечисления можно определить все операторы,
 существующие в языке C++: `+`, `-`, `*`, `/`, `%`, `[]`, `()`, `^`, `!`, `&`, `<`, `<=`, `>=` и др  ).
 Применяется, когда требуется сохранить привычные обозначения для
 разрабатываемого нами типа. Рассмотрим пример:
```cpp
  enum class Month {
    Jan = 1, Feb, Mar, Apr, May, Jul, Aug, Sep, Oct, Nov, Dec
 };
 
 Month operator++ (Month& m){ //перегрузка оператора ++
   m = (m == Dec)?Jan:Month(int(m)+1);
   return m;
 }

 vector<string> month_tbl = {"", "Jan", "Feb", ... "Dec"};
 ostream& operator<<(ostream& os, Month m) { //перегрузка оператора <<
   return os << month_tbl[int(m)];
 }
```

## 16. Перегрузка оператора вызова и функциональные объекты. Лямбда-выражения.
При объявлении класса есть возможность перегрузить `operator()`, получив таким образом функциональный объект - `функтор` - то есть класс, объекты которого могут вести себя как функции с точки зрения пользователя.
Это может быть удобно для сохранения каких-либо данных - например, про количество вызванных таким образом операторов()
```cpp
class MyClass {
public:
    MyClass() {}
    static int counter;
    int operator()(int a, int b) {
    ++counter;
    return a + b;
}

};

int MyClass::counter = 0;

int main() {
    MyClass summ1;
    MyClass summ2;
    cout << summ1(2, 5) + summ2(1, 4);
}
```
Выведено будет 12, и `summ1.counter == summ2.counter == MyClass::counter == 2`

`Лямбда - выражения` - это анонимные функции. Синтаксис следующий:
```cpp
[`захваченные снаружи переменные`](`параметры лямбда - функции`) {`тело функции`}
```

Лямбды могут применяться, например, для передачи в функции:
```cpp
...
struct T {
    T() {}
    int field {0};
};
...
int n = 9;
bool is_raise = false;
std::vector<T> vec(n)
...
std::sort(vec.begin(), vec.end(), [flag](const T& a, const T& b){
if(flag) return a.field > b.field;
else return a.field < b.field;
})
...
```
Таком образом можно отсортировать вектор так, как нам необходимо, даже если `operator<` у класса `T` не перегружен.

## 17. Наследование. Ключевые слова virtual и override
Наследование - один из основополагающих принципоп парадигмы объектно-ориентированного программирования. Благодаря наследованию можно избежать дублирования кода, к тому наследование помогает логически организовать код. Класс, от которого происходит наследование, называется "родительским" ("суперклассом", "базовым"), а класс, который наследует - "дочерний" ("подкласс", "производный").
Синтаксис наследования:
```cpp
class sub_class : <inheritance_type> super_class
{ ... }
```
Типы наследования:
+ `public` (уровень доступа к данным не меняется)
+ `protected` (`public` становится protected, остальное не меняется)
+ `private` (все унаследованные данные становятся `private`)
Виртуальные функции - функции родительского и дочернего класса с одинаковыми именами, возвращаемыми типами и типами аргументов. Эта возможность позволяет реализовать полиморфизм времени выполнения (или, по-другому, динамическая диспетчеризация). Для обработки виртуальных функций классу требуются `vtbl` (таблица виртуальных функций) и vptr (указатель на `vtbl`). При вызове метода для объекта x какого-то класса код перейдет через таблицу виртуальных функций к нужной функции для вызова.
```cpp
virtual void do_something ();
```
Создается виртуальная функция с помощью спецификатора `virtual`. Виртуальную функцию может переопределить дочерний класс.
Абстрактный класс - класс, который можно использовать только в качестве родительского.
Сделать класс абстрактным можно созданием чисто-виртуальной функции (функции, которыми должны быть определены в дочерних классах).
```cpp
virtual void do_something () = 0;
```
Для указания того, что функция должна перекрывать виртуальную функцию базового класса, используется ключевое слово `override`.
Пример:
```cpp
class Enemy
{
virtual void attack () = 0;
virtual void run () { /*code*/ };
};
class Soldier : public Enemy
{
void attack () override { /*code*/ };
void run () override { /*code*/ }
};
```

## 18. Шаблонные функции и классы.
По существу, шаблон (template) - это механизм, позволяющий программисту
 использовать типы в качестве параметров класса или функции. Получив эти
 аргументы, компилятор генерирует конкретный класс или функцию.
 ```cpp
 //почти реальны вектор элементов типа Т
  template<typename T> class vector{
   // читается как "для всех типов Т"
   int sz;
   T* elem; // указатель на элементы
   // ...
   };
   
   template<typename T>
   void vector<T>::push_back(const T& d) {/*.../*};
```
Вариант шаблона для конкретного набора шаблонных аргументов называется
специализацией. Процесс генерации специализаций на основе шаблона 
и набора аргументов называется инстанцированием шаблона.
```cpp
  template<typename T>
   struct Compare {		//обобщенное сравнение
	bool operator() (const T& a, const T& b) const
	{
		return a<b;
	}
   };
   template<>
   struct Compare<const char*> {	//Сравнение C-строк
	bool operator() (const char* a, const char* b) const
	{
		return strcmp(a,b) < 0;
	}
  };
```

## 19. Стиль оформления программ. Правила "хорошего тона"

## 20. Этапы и средства разработки программ.

Процесс разработки программ можно разделить на четыре этапа.
• `Анализ`. В чем заключается задача? Чего хочет пользователь? Что требуется пользователю? Что может позволить себе пользователь? Какая степень надежности нам необходима?
• `Проектирование`. Как решить задачу? Какую структуру должна иметь система? Из каких частей она должна состоять? Каким образом эти части будут взаимодействовать? Каким образом система будет взаимодействовать с пользователем?
• `Программирование`. Выражение решения задачи (проекта) в исходном тексте. Написание программы с учетом всех установленных ограничений (по времени, объему. финансам, надежности и т.д.).
Проверка. что программа работает правильно и удобна в сопровождении.
• `Тестирование`. Проверка. что во всех предусмотренных ситуациях система работает правильно. (очень важный этап. Даже если вам кажется, что все написано верно, не поленитесь и протестируйте все возможные паттерны поведения, а не только наиболее вероятные.)

## 21. Обработка ошибок. Возможные альтернативы. Механизм исключений
Классификация ошибок:
+ ошибки времени компиляции (`compilation errors`): синтаксические ошибки, ошибки типов и тд
+ ошибки времени выполнения (`run time errors`): ошибки, обнаруженные компьютером, библиотекой или кодом пользователя
+ ошибки времени редактирования связей: ошибки при попытке объединения объектных файлов в выполнимый модуль
+ логические ошибки (`logic errors`)
Случаи, в которым можно не обрабатывать ошибки:
+ ошибки аппаратного обеспечения, операционной системы
+ нет возможности изменить определение функции
+ пользователю нужно знать об ошибки, что предпринять какие-либо действия
+ значительное уменьшение производительности в случае обработки
Две альтернативы обработки ошибок:
+ обработка в вызывающем коде (непрактично, кроме случая, когда нет доступа к изменению вызываемого кода, то есть добавления обработки; может привести к дублированию кода, его нечитаемости)
+ обработка в вызываемом коде (логичный выход; в некоторых случаях невозможно реализовать)
Механизм исключений (реализуется с помощью try, catch и throw). Основная идея: отделение кода, который может генерировать исключения, от кода, обрабатывающего эти исключения.
Синтаксис:
```cpp
try {
  // код ... 
}
catch (/*тип ошибки или "..." для любых случаев*/) {
  // обработка ошибки ...
}
```
Может быть несколько блоков `catch` для разных типов.
Обычно в блоке `catch`:
 - выводится сообщение об ошибке
 - исключение отправляется "выше", в другой блок `try-catch`
Исключения генерируются с помощью оператора `throw`
```cpp
throw std::runtime_error{"error"};
throw "error";
throw -1;
```

## 22. Способы организации структуры и взаимодействия в программе:

### 22.1. 
a)ОБЪЯВЛЕНИЕ предоставляет основные свойства символа: его тип и его название.
 ОПРЕДЕЛЕНИЕ предоставляет все детали этого символа — если это функция, что она делает;
 если это класс, какие у него поля и методы; если это переменная, где эта переменная находится.
 Часто, компилятору нужно объявление, чтобы скомпилировать файл в объектный файл,
 так как компоновщик может найти определение из другого файла.
 Если исходный файл не определяет символ, но он объявлен,
 во время компоновки вы будете получать ошибки, сообщающие о неопределенных символах.
 Использование extern позволяет объявить переменную, не определяя ее, он сообщает, что переменная находится где-то в другом месте.
 extern int x;
 int func()
 {
    x = 3;
 }
 б) Память компьютера представляет собой последовательность байтов.
	Эти байты нумеруются от нуля до последнего байта. Адресом
	(address) называют некоторое число, идентифицирующее ячейку в
	памяти. Адрес можно считать разновидностью целых чисел. Первый байт
	памяти имеет адрес О, второй - 1 и т.д.
	В принципе, память компьютера можно рассматривать как последовательность
	байтов, пронумерованную от О до размера памяти в байтах минус единица.

 в)Существует пять видов областей видимости.
  • Глобальная область видимости (global scope). Имя находится в глобальной
	области видимости, если только оно не объявлено в некоторой
	языковой конструкции (например, в классе или функции).
  • Область видимости пространства имен (namespace scope). Имя находится
	в области видимости пространства имен, если оно определено
	в пространстве имен, но не в какой-либо языковой конструкции
	(например. в классе или функции) . Формально говоря, глобальная область
	видимости - это область видимости пространства имен с "пустым
	именем".
  • Локальная область видимости (local scope). Имя находится в локальной
	области видимости, если оно объявлено в функции (это определение
	включает параметры функции).
  • Область видимости класса (class scope). Имя находится в области
	видимости класса, если оно является именем члена этого класса.
  • Область видимости инструкц??ш (statement scope). И мя находится
	в области видимости инструкции , если оно объявлено в части ( . . . )
	инструкций for, while, switch или if.


### 22.2. Функции. Механизм вызова, организация стека активационных записей. Рекурсия
Функция - фрагмент программного кода, к которому можно обратиться из другого места программы. В языке C++ допускаются именованные и безымянные (`lambda`) функции. После выполнения функции управление возвращается обратно в адрес вызова - точку программы, откуда данная функция была вызвана.
При вызове функции реализация ЯПа создает структуру данных, содержащую копии всех ее параметров и локальных переменных.
Например, вызывая функцию:
```cpp
int sum (int a, int b)
{
  int res = a + b;
  return res;
}
```
Компилятор создаст структуру (запись активации функции), хранящую в себе `a`, `b` и `res`, а также детали реализации, которые варьируются от компилятора к компилятору.
С точки зрения реализации параметр представляет собой всего лишь одну из локальных переменных.
Вывозвы функций хранятся в стеке. Вызовы обрабатываются по принципу (последний добавился - первый вышел). То есть при добавлении вызова функции в стек вызовов, сначала обработается вызванная функция, а затем программа вернется к месту вызова. Такой стек называется стеком записей активации (или стек вызовов).
Рекурсия - вызов функции в самой функции. Ввиду существования рекурсии был существует и рекурсивный подход - использование рекурсии в алгоритмах.
Пример рекурсии:
```cpp
int pow (int a, int n)
{
  if (n == 1)
    return a;
  else
    return a * pow(a, n-1);
}
```
Во время написания рекурсивных функций надо продумать правильное условия выхода, иначе рекурсия может стать бесконечной.

### 22.3. Способы передачи параметров в функцию
Существуют разные способы передачи параметров в функцию:
+ Передача копированием (`int f (int f);`). Используется для базовых или маловесных типов. При передаче массивных данных следует использовать один из 2 следующих типов.
+ Передача по ссылке (`int multiple (std::vector<int>& v, int a);`). Используется в случае, если переданную переменную нужно изменить.
+ Передача по константной ссылке (`int sum (const std::vector<int>& v);`). Используется для оптимизации по памяти, чтобы исключить копирование. Причем лучше использовать именно константную сслылку, если нет надобности изменять данные.
+ Передача функции (`double integral (double (*f)(double));`, или `double integral (double (f)(double));`, или `double integral (double f(double));`). Случаи использования очевидны.

### 22.4. Классы: интерфейс и реализация. Модифицирующие и немодифицирующие методы
Часто для представления каких-либо предметов, явлений или других сущностей в программе используются классы. Классы хранят совокупность объектов разного типа, а также методов.
Функция, объявленная в классе - функция-член (или метод), переменная - параметр (или поле).
Интерфейс класса - это область класса, которая должна быть доступна пользователю (описывается в `public`), реализация - это все, что осуществляет работу интерфейса (описывается в `private`). Правилом хорошего тона является правильное отделение интерфейса от реализации.
Методы класса могут быть модифицирующими (меняют поля класса) или немодифицирующими (не меняют поля класса; если это гарантированно, лучше поставить ключевое слово `const` после записи параметров).
```cpp
struct Student
{
  // ...
  int get_group_id () const; // const, тк не меняем ничего
  void set_group_id (int group); // устанавливаем группу, поэтому не const
}
```

### 22.5 Создание и инициализация объектов. Конструкторы класса.
Для стандартных типов в С++ есть возможность объявить их без инициализации (`int a; bool b;`). Память под переменную будет выделена, но в ячейках будет находиться мусор.
Инициализацию можно произвести с помощью универсального инициализатора `{}` или с помощью присваивающего оператора `=`. Для пользовательских типов инициализация может быть по умолчанию:
```cpp
class MyClass{
public:
int field = 0;
MyClass(){}
};
```
Или же поля инициалицируются в конструкторе:
```cpp
class MyClass{
public:
int field1;
int field2;
int field3;
MyClass(): field1{0}, field2{333}, field3{90} {}
};
```
Конструктор - это функция, которая вызывается каждый раз, когда создается объект класса. Правилом хорошего тона и залогом безопасного программирования является инициализация всех полей (`в особенности указателей!`)
в конструкторе или в классе по умолчанию. Наличие неинициализированных полей у объекта класса, вероятно, приведет вас к ошибке или непредвиденному поведению.
Конструктор, не принимающий никаких аргументов, называется конструктором по умолчанию.

```cpp
class MyClass{
public:
MyClass(); //конструктор по умолчанию
explicit MyClass(int n); //конструктор с одним аргументом
MyClass(const std::initializer_list<int>& lst) //Конструктор со списком инициализации
MyClass(const MyClass& other); //конструктор копирования
Myclass(MyClass&& other); //конструктор перемещения
};
...
MyClass obj1; //конструктор по умолчанию
MyClass obj2(34); //конструктор с одним аргументом
MyClass obj4 {1,2,5,8}; //конструктор со списком инициализации
MyClass obj3(obj2); //конструктор копирования
MyClass obj5(std::move(obj1)); //конструктор перемещения

```
Обращаю Ваше внимание на ключевое слово `explicit`. Оно обозначает, что конструктор с одним аргументом - это именно конструктор, но не в коем случае не оператор приведения какого-то типа (в данном случае `int`)
к типу `MyClass`, как, например, приведение типа `double` к типу `int`:
```cpp
double d = 1.32335;
int i;
i = int(d);
```
Выражение `int(d)` означает приведение типа переменной `d` к типу `int`.
Так же обращаю ваше внимание, что `если конструктор копирования не определен, то по умолчанию применяется поверхностное копирование`! Будьте аккуратны с этим, если ваш объект владеет какими-то ресурсами.

### 22.8. Наследование. Абстрактные классы. Механизм виртуальных функций
Все и более того есть в билете №17.

### 22.9. Уничтожение объектов. Деструктор класса. Виртуальный деструктор
Деструктор — это функция-член, которая вызывается автоматически, когда объект выходит из области действия или явно уничтожается вызовом метода `delete`.
Созданный компилятором деструктор по умолчанию вызывает деструктор всех членов, у которых есть деструктор. Если ведется работа с памятью, хорошим тоном или даже необходимостью будет определение своего деструктора. Например, создавая структуру:
```cpp
struct Memory
{
  X* xarr;
  // ...
}
```
Но не определив деструктор по умолчанию, деструктор `Memory` только лишь обнулит указатель. Но это противоречит идиоме RAII и приведет к утечке памяти, поэтому следует переопределить деструктор.
При реализации наследования есть смысл сделать деструктор базового класса виртуальным, чтобы гарантировать правильный вызов деструкторов при уничтожении объекта. Иначе при создании объекта дочернего типа деструктор для него может быть не вызван. Это может привести к утечкам памяти.
Пример:
```cpp
struct Person
{
  // ...
  ~Person () { /* ... */ } // деструктор не виртуальный 
}
struct MiptStudent : Person
{
  MiptStudent () { dolgi = new Dolg[1000000]; }
  ~MiptStudent () { delete[] dolgi; }
private:
  Dolg* dolgi;
}
```
При вызове деструктора для `Person` компилятор не может гарантировать вызов деструктора для `MiptStudent` (останутся `dolgi`). Если сделать деструктор `Person` виртуальным, то тогда все деструкторы вызовутся правильно (в порядке наследования: базовый -> дочерний) и `dolgi` уйдут (хух, можно радоваться, что долгов нет, ураааа).

### 22.10. Поддержка копирования и перемещения
При написании классов и структур, работающих с памятью, нужно придерживаться "правила пяти": определить деструктор, конструктор копирования, конструктор перемещения, оператор присваивания копированием и оператор присваивания перемещением.
Суть перемещения: нужно "украсть" данные у одного объекта и "отдать" их другому. Если есть указатель на ресурс, то нужно, во-первых, скопировать его в объект, в который нужно переместить другой, и, во-вторых, обнулить указатель на ресурс у другого объекта. Базовые типы (`int`, `double`, указатели и т. д.) не перемещаются, они копируются.
Суть копирования: создать копию данных для объекта. Причем может быть 2 типа копирования: глубокое и поверхностное. Поверхностное копирование копирует только указатель на ресурс, поэтому в результате на один и тот же ресурс могут указывать 2 указателя. Глубокое копирование копирует информацию, на которую указывает указатель.
Класс поддерживает перемещение и копирование, если для него определены операторы и конструкторы копирования и перемещения.
```cpp
struct Memory
{
  Memory (Memory&&);
  Memory (const Memory&);
  
  Memory& operator = (Memory&&);
  Memory& operator = (const Memory&);
}
```

### 22.11. Управление ресурсами и исключения. Принцип RAII. «Умные» указатели
При создании классов, работающих с памятью, могут возникнуть проблемы, связанные с исключениями. Рассмотрим пример: при вызове конструктора или оператора присваивания для вектора вызывается конструктор для типа, который хранится в векторе. Но конструктор может сгенерировать исключение. В этом случае нужно предусмотреть очистку занятой памяти после срабатывания исключения. Такое копирование и заполнение доступны в стандартной библиотеке благодаря функциям `std::uninitialized_copy(T* first, T* last, T* result)` и `std::uninitialized_copy(T* first, T* last, const T& val)` соответственно.
RAII (Resource Acquisition Is Initialization) - одна из идиом ООП. Ее суть: получение ресурса неразрывно связано с инициализацией, а его освобождение - с уничтожением объекта. Например, разрабатывая класс `vector_base`, который должен работать с памятью, мы должны предусмотреть освобождение ресурса, если выделили его в конструкторе, и, наоборот, выделение, если освобождаем память в деструкторе.
В функциях нужно также предусмотреть обработку исключений. Если функция создавала объекты и(или) резервировала память, но возникло исключение, которое обрубает работу функции, нужно уничтожить объекты и(или) освободить память.
Пример:
```cpp
template<typename T, typename A = std::allocator<T>>
T* uninitialized_copy(T* first, T* last, T* target)
{
  A alloc;
  T* cur = target;
  try
  {
    for (; first != last; ++first, ++cur)
      alloc.construct(cur, *first); // создаем объекты
    return target;
  }
  catch (...)
  {
    for (; target != cur; ++target)
      alloc.destroy(target); // удаляем все, что создали, в случае исключения в консрукторе
    throw;
  }
}
```
Умные указатели - специализированный класс, имитирующий интерфейс обычного указателя и добавляющий необходимую функциональность. Умные указатели бывают разные: `unique_ptr`, `counted_ptr` и т. д.
Умные указатели помогают избежать:
+ утечки памяти
+ двойного удаления одного ресурса
`unique_ptr` - умный указатель единоличного пользования. Его нельзя копировать. При удалении удаляется и сам объект.
`shared_ptr` - умный указатель с счетчиком. Объект удаляется при удалении последнего `shared_ptr` на данный объект.

## 24. Ввод и вывод в программе. Модель потоков ввода–вывода. Обработка ошибок
Для работы с потоками ввода и вывода в C++ есть стандартная библиотека. Чтобы начать работать с вводом и выводом, нужно подключить `<iostream>`.
Оператор `<<` помещает значение в поток. Оператор `>>` извлекает значения из потока.
Стандартные объекты потоков: `std::cin`, `std::cout`, `std::cerr`, - работают с консолью.
Для удобства в некоторых ситуациях можно создать свои классы для обработки потоков ввода/вывода. Например, для ввода только символов английского символа.
Для этого следует:
1. Объявить класс
2. Перегрузить оператор ввода/вывода
3. Задать поля для хранения буфера, а также стандартного потока вводав/выывода
4. Настроить свою кастомизацию для потока (например, игнорировать введенные не буквы)
Шаблон переопределенного потока ввода:
```cpp
class MyStream
{
public:
  MyStream (istream& is)
    : source{ is } { }
  // ...
  MyStream& operator>> (string& s)
private:
  istream source;
  // ...
}
```
Есть возможность вывода в файл и чтения из файла. Для этого нужно определить файловые потоки:
```cpp
#include <fstream>

int main(){
std::ofstream out("`path to file`") //поток вывода в файл
std::ifstream in ("`path to file`") //поток ввода из файла
int i;
in >> i;
out << i*2;
return 0;
}
```

Часто требуется обработка ошибок для вводимых значений.
Поток `std::cin` может находиться в нескольких состояниях:
+ `std::cin.good()` - все гуд
+ `std::cin.eof()` - конец файла, закрытие потока
+ `std::cin.fail()` - плохо
+ `std::cin.bad()` - капец плохо (не обрабатываем)

Проверка `std::cin >> val` помогает понять статус введенного значения.
